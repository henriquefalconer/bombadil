0a. Study @SYNTHESIS.md first for a comprehensive overview of the codebase architecture, module responsibilities, key types, data flow, design decisions, and test coverage. This is the primary reference and should be read before any code exploration.
0b. Study @IMPLEMENTATION_PLAN.md (if present) to understand the plan so far.
0c. Study @PATTERNS.md (if present) for simple, generic rules derived from the upstream codebase. All new code must follow these patterns to stay consistent with existing conventions.
0d. Use up to 250 parallel Sonnet subagents to deep-dive into specific modules as needed, guided by @SYNTHESIS.md. Focus on areas relevant to the current task rather than blanket exploration.
0e. For reference (also documented in @SYNTHESIS.md): the project is a Rust+TypeScript coverage-guided property-based web UI testing tool. Rust source is in `src/` (core engine). TypeScript specification DSL is in `src/specification/*.ts` (user-facing `@antithesishq/bombadil` API). Integration tests are in `tests/` (HTML fixtures + `integration_tests.rs`). Inline unit tests and `insta` snapshot tests live alongside Rust source files.

1. Study @IMPLEMENTATION_PLAN.md (if present; it may be incorrect) and use up to 500 Sonnet subagents to study existing source code in `src/` (Rust + TypeScript) and `tests/` and compare against project goals. Use @SYNTHESIS.md as the architectural reference to guide your audit — it documents all modules, key types, data flow, design decisions, and test coverage. Use an Opus subagent to analyze findings, prioritize tasks, and create/update @IMPLEMENTATION_PLAN.md as a bullet point list sorted in priority of items yet to be implemented. Ultrathink. Consider searching for TODO, minimal implementations, placeholders, skipped/flaky tests, `#[allow(unused)]` markers, and inconsistent patterns. Key areas to audit (see @SYNTHESIS.md for detailed descriptions): LTL evaluator (`specification/ltl.rs`), browser state machine (`browser.rs`), instrumentation coverage (`instrumentation/js.rs`), action generation (`specification/defaults/actions.ts`), verifier (`specification/verifier.rs`), runner loop (`runner.rs`). Study @IMPLEMENTATION_PLAN.md to determine starting point for research and keep it up to date with items considered complete/incomplete using subagents.

IMPORTANT: Plan only. Do NOT implement anything. Do NOT assume functionality is missing; confirm with code search first. Use @SYNTHESIS.md to understand existing architecture before proposing changes — it covers all modules, types, and design decisions. Treat `src/specification/*.ts` as the user-facing DSL and `src/specification/*.rs` as the Rust-side specification engine. Prefer idiomatic Rust patterns and existing module boundaries over ad-hoc additions. Follow all rules in @PATTERNS.md (if present) so that new code maintains consistency with established conventions. You can commit your changes. Don't let @IMPLEMENTATION_PLAN.md get too big with too many unnecessary historical tracking details. Clean up the implementation plan to focus on what's relevant going forward, removing some historical tracking details. Keep @SYNTHESIS.md up to date if significant architectural changes are planned.

ULTIMATE GOAL: We want to achieve [project-specific goal]. Consider missing elements and plan accordingly. If an element is missing, search first to confirm it doesn't exist, then if needed document the plan to implement it in @IMPLEMENTATION_PLAN.md using a subagent.